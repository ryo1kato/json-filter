#!/usr/bin/env python
#
# Dumb simple JSON accessor with dotdict notation support.
#
# Dotdict notation of "data.capacityList[0].capacity.hostName"
# is equivalent to "['capacityList'][0]['capacity']['hostName']" of Python
#

VERSION = (0,2)
USAGE = """\
%prog [OPTIONS] [FILENAME] [JSON_DITDICT]
%prog --csv [OPTIONS] [FILENAME] [JSON_DITDICT] [--columns=COLNAME1[,COLNAME2[,...]]]
DESCRIPTION
  Simple JSON analyzer and filter with dotdict notation + wildcard support.
JSON_DOTDICT
  attr1.attr2[999].attr3
  attr1.attr2[*].attr3
  attr1.attr2.attr3(attr4=val4)
  attr1.attr2.attr3.attr4(=val4)
\
"""

#
# TODO
#   * top-level array
#   * CSV output
#   * Better error and exception handling
#   * '*' wildcard for node name
#   * Unit test
#   * Multiple subscript / range support for list (subscript_str)
#
# BUGS & KNOWN ISSUES
#   * Not for big data; this script loads entire input into memory as
#     objects (using json.load() method), thus input must hit into
#     your machines' RAM.
#   * Nested arrays are not supported
#

##############################################################################
import os
import sys
import re
import optparse
import json

#sys.tracebacklimit = 2

class OutFormat:
    Auto, JSON, CSV = range(3)

##############################################################################

def is_number(obj):
    if isinstance(obj, int) or isinstance(obj, long) or isinstance(obj, float):
        return True
    else:
        return False


def is_rawtype(obj):
    return isinstance(obj, basestring) or is_number(obj)



##############################################################################
# "name" is shorthand for "TOP.name" or "TOP[*].name"
# "[99].name" is shorthand for "TOP[99].name"
# "name1.name2" is shorthand for "name1[*].name2" or even "name1[*].name2"
# when name1 and/or name2 is an array.



def debug(msg):
    print "DEBUG: ", msg
    pass

res = {
        "delim": "[\[\{\.]",
        "name":  ".([A-Za-z]\w*)",
        "index": "(?:\[(?P<index>\d+|\*)\])"
}
re_delim = re.compile("^%(delim)s"%res)
re_name  = re.compile("^%(name)s(?P<rest>%(delim)s.+)*$" % res)
re_index = re.compile("^%(index)s(?P<rest>%(delim)s.+)*$" % res)
#re_multi = re.compile(".\{[^\{\}]*[^\\]\}(?<rest>%(delim)s)" % res)

class DotDictError(Exception):
    def __init__(self, msg=''):
        self.msg = msg
    def __str__(self):
        return self.msg

class DotDictMalformed(DotDictError):
    pass

class DotDictNoMatch(DotDictError):
    pass



def dotdictget(myjson, dotdict):
    """Wrapper for _dotdictget() to allow omiting topmost object/array index
    """
    if re_delim.match(dotdict):
        normalized_dotdict = dotdict
    else:
        normalized_dotdict = '.' + dotdict

    return _dotdictget(myjson, normalized_dotdict, [])



def _dotdictget_dict(mydict, name, rest, traversed=[]):
    trace = traversed+["."+name]
    try:
        if isinstance(mydict, list):
            # assume shorthand notation; name1.name2 is
            # equivalent to name1[*].name2 if name1 is a list.
            subtree = [ _dotdictget(j[name], rest, trace) for j in mydict ]
        else:
            subtree = _dotdictget(mydict[name], rest, trace)
        return {name: subtree}
    except KeyError:
        raise DotDictNoMatch(trace)


def _dotdictget_list(mylist, index_s, rest, traversed=[]):
    trace = traversed+["[%s]"%index_s]
    if isinstance(mylist,list):
        if index_s == '*':
            return [ _dotdictget(j, rest, trace) for j in mylist ]
        else:
            index = int(index_s)
            try:
                subtree = _dotdictget(mylist[index], rest, trace)
                return [subtree]
            except IndexError:
                raise DotDictNoMatch(trace)
    else:
        raise DotDictNoMatch(trace)


def _dotdictget(myjson, dotdict, traversed=[]):
    debug("dotdict: '%s'"%dotdict)
    if not dotdict or dotdict == '':
        debug("  Leaf: " + ''.join(traversed))
        return myjson
    else:
        m_name  = re_name.match(dotdict)
        m_index = re_index.match(dotdict)
        #m_multi = re_multi.match(dotdict)
        if m_name:
            name = m_name.group(1)
            rest = m_name.group('rest')
            return _dotdictget_dict(myjson, name, rest, traversed)

        elif m_index:
            index_s = m_index.group(1)
            rest  = m_index.group('rest')
            return _dotdictget_list(myjson, index_s, rest, traversed)

        else:
            raise DotDictMalformed(dotdict)





##############################################################################

def print_json_pretty(obj, force=False):
    """If obj is simply an array or raw data type, or a dict with
    only key-value pair in it, print as text.
    Otherwise dump it as JSON.
    """
    if is_rawtype(obj):
        print obj
    elif isinstance(obj, list):
        if all([ is_rawtype(i) for i in obj ]):
            for item in obj:
                print item
        elif all([ isinstance(i, dict) and len(i.keys()) == 1 and is_rawtype(i.values()[0])
                 for i in obj ]):
            for one_item_dict in obj:
                print one_item_dict.values()[0]
        elif not force:
            print json.dumps(obj, indent=4)
        else:
            # failed to pretty-print the object and need to back-track
            return True
    elif isinstance(obj, dict) and len(obj.keys()) == 1:
        # if the obj is dict with one key, try to pretty the inner obj.
        # FIXME for 'single1.single2_3.single3_3'
        if print_json_pretty( obj.values()[0], force=True ):
            if force:
                return True
            else:
                print json.dumps(obj, indent=4)
    elif force:
        return True
    else:
        print json.dumps(obj, indent=4)


def print_csv_dict(myDictList, filter_columns=None, escape=True):
    """print array of dict as csv
    """
    def getcol(row, col):
            if colname in row:
                return str(row[colname])
            else:
                return '__' + colname + '__'

    if filter_columns:
        colnames = filter_columns
    else:
        colnames = myDictList[0].keys()

    for row in myDictList:
        # FIXME: check here data type(?) is dict for all rows
        cols = [ getcol(row, colname) for colname in colnames ]

        # FIXME: should escape the comma
        #for cell in cols:
        #    if ',' in cell:
        #        raise ValueError("',' in the data")

        print ','.join( cols )


def print_csv_list(myListList, filter_columns=None, escape=True):
    nr_cols = len(myListList[0])

    if filter_columns:
        for row in myListList:
            print ','.joins(   [ row[int(col)] for col in filter_columns ]  )
    else:
        for row in myListList:
            print ','.join( row )


def print_csv(mylist, filter_columns=None, escape=True):
    if not isinstance(mylist, list):
        raise TypeError("Non-list data")

    if isinstance(mylist[0], dict):
        print_csv_dict(mylist, filter_columns, escape)
    elif isinstance(mylist[0], list):
        print_csv_list(mylist, filter_columns, escape)
    elif is_rawtype(mylist[0]):
        for item in mylist:
            print item
    else:
        raise TypeError("Unrecognizable data")



##############################################################################

def myoptparse(argv):
    ## Option Parser
    parser = optparse.OptionParser(
        usage=USAGE,
        version=("%%prog %d.%d" % VERSION) )

    parser.add_option("-a", "--auto",
        action="store_const", dest="outformat", const=OutFormat.Auto,
        help="Output in JSON format for complex data structure, " +
             "text output for data only with primitive data type (default)")

    parser.add_option("-c", "--csv",
        action="store_const", dest="outformat", const=OutFormat.CSV,
        help="Output in Comma Separated Value format.")

    parser.add_option("-j", "--json",
        action="store_const", dest="outformat", const=OutFormat.JSON,
        help="Output in JSON format even for simple array only with primitive data type, " +
             "like array of numbers or strings")



    #parser.add_option("-H", "--no-csv-header",
    #    action="store_true",
    #    help="Print header for Comma Separated Value output.")

    (opt, args) = parser.parse_args(argv)
    return (opt, args) 


def json_filter(args):
    infile  = sys.stdin
    dotdict = None
    if len(args) == 0:
        pass
    elif len(args) == 1:
        if os.path.exists(args[0]):
            infile  = open(args[0])
        else:
            dotdict = args[0]
    elif len(args) == 2:
        infile  = open(args[0])
        dotdict = args[1]
    else:
        sys.stderr.write("Too many (%d) arguments\n"%len(args))
        sys.exit(1)

    if dotdict:
        myjson = dotdictget( json.load(infile), dotdict )
    else:
        myjson = json.load( infile )


    if dotdict and len(myjson) == 0:
         raise ValueError("No matching JSON attribute found in the input")

    return (myjson, dotdict)


def main():
    try:
        (opt, args) = myoptparse(sys.argv[1:])
        (myjson, dotdict) = json_filter(args)

        if opt.outformat == OutFormat.CSV:
            #print json.dumps(myjson, indent=4)
            #for row in json2table( myjson, dotdict ):
            #    print ",".join(row)
            pass
        elif opt.outformat == OutFormat.JSON:
            print json.dumps(myjson, indent=4)
        else:
            print_json_pretty(myjson)

    except KeyboardInterrupt:
        sys.exit(1)


if __name__ == "__main__":
    main()
