#!/usr/bin/env python
#
# Dumb simple JSON accessor with dotdict notation support.
#
# Dotdict notation of "data.capacityList[0].capacity.hostName"
# is equivalent to "['capacityList'][0]['capacity']['hostName']" of Python
#

VERSION = (0,1)
USAGE = """\
%prog [OPTIONS] [JSON_DITDICT]
DESCRIPTION
  Simple JSON analyzer and filter with dotdict notation + wildcard support.
JSON_DOTDICT 
  attr1.attr2[999].attr3
  attr1.attr2[*].attr3
  attr1.*.attr3
\
"""

#
# TODO
#   * Unit test
#   * Multiple subscript / range support for list (subscript_str)
#
# BUGS & KNOWN ISSUES
#   * Not for big data; this script loads entire input into memory as
#     objects (using json.load() method), thus input must hit into
#     your machines' RAM.
#

##############################################################################
import sys
import re
import optparse
import json

sys.tracebacklimit = 2


##############################################################################

def is_number(obj):
    if isinstance(obj, int) or isinstance(obj, long) or isinstance(obj, float):
        return True
    else:
        return False

def is_rawtype(obj):
    return isinstance(obj, basestring) or is_number(obj)



##############################################################################
re_name      = "([A-Za-z]\w*)"    # group 1
re_subscript = "(\[(\d+|\*)\])?"  # group 2 and 3
re_condition = "(\([=<>]\w+(\|[=<>]\w+)*\))?"
re_node      = {'re_node': re_name + re_subscript + re_condition}

re_dotdict    = re.compile("^%(re_node)s$" % re_node)
re_dotdict_multi = re.compile("^\{(%(re_node)s(,%(re_node)s)*)\}$" % re_node)



def dotdictget(myjson, dotdict):
    print "dotdictget: " + dotdict + " (" + str(type(myjson)) + ")"
    node_str, _, rest = dotdict.partition('.')

    single_node = re_dotdict.match(node_str)
    multi_node  = re_dotdict_multi.match(node_str)

    if single_node:
        keys = [ node_str ]
    elif multi_node:
        keys = multi_node.group(1).split(',')
    else:
        raise ValueError("Malformed JSON object path")

    if isinstance(myjson, list):
        return [ dotdictget2(j, keys, rest) for j in myjson ]
    else:
        return dotdictget2(myjson, keys, rest)


# handle (multiple) path name and conditions
def dotdictget2(myjson, keys, rest):

    filtered = dict()

    for key in keys:
        parsed = re_dotdict.match(key)
        name       = parsed.group(1)
        subscript  = parsed.group(3)
        conditions = parsed.group(4) # FIXME: not implemented yet.

        rawobj = myjson[name]

        if not subscript or subscript == '':
            objs = rawobj
        else:
            if not isinstance(rawobj, list):
                raise TypeError("Invalid JSON object path: %s is not an array"%name)

            if subscript == '*':
                objs = rawobj
            else:
                objs = [ rawobj[int(subscript)] ]

        if not rest or rest == '':
            filtered[name] = objs
        else:
            filtered[name] = dotdictget(objs, rest)

    return filtered

def print_json(j, csv=False):
    if is_rawtype(j):
        print j
    elif isinstance(j, list) \
         and len(j) == len([i for i in j if is_rawtype(i)]):
        for item in j:
            print item
    else:
        print json.dumps(j, indent=4)


##############################################################################
def list2csv(mylist, filter_columns=None, print_header=True, escape=True):
    if not isinstance(mylist, list):
        raise TypeError("Non list data")

    if print_header:
        if filter_columns:
            print ','.join( filter_columns )
        else:
            print ','.join( mylist[0].keys() )

    def getcol(colname, row):
            if colname in row:
                return str(row[colname])
            else:
                return '__' + colname + '__'

    for row in mylist:
        if filter_columns:
            cols = [ getcol(col, row) for col in filter_columns ]
        else:
            cols = [ str(val) for val in row.values() ]

        for cell in cols:
            if ',' in cell:
                raise ValueError("',' in the data")

        print ','.join( cols )



##############################################################################

def main():
    ## Option Parser
    parser = optparse.OptionParser(
        usage=USAGE,
        version=("%%prog %d.%d" % VERSION) )

    parser.add_option("--csv",
        action="store_true",
        help="Output in Comma Separated Value format.")

    parser.add_option("-H", "--no-csv-header",
        action="store_true",
        help="Print header for Comma Separated Value output.")

    (opt, args) = parser.parse_args(sys.argv)


    ## Load JSON txt
    myjson = json.load(sys.stdin)


    ## ...and print
    if len(sys.argv) < 2:
        # if no dotdict path specified, dump them all
        print_json( myjson, csv=opt.csv )
    else:
        obj = dotdictget(myjson, sys.argv[1])
        if len(obj) == 0:
             raise ValueError("No matching JSON attribute found in the input")
        else:
            print_json(obj, csv=opt.csv)



if __name__ == "__main__":
    main()
