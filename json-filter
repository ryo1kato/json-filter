#!/usr/bin/env python
#
# Dumb simple JSON accessor with dotdict notation support.
#
# Dotdict notation of "data.capacityList[0].capacity.hostName"
# is equivalent to "['capacityList'][0]['capacity']['hostName']" of Python
#

VERSION = (0,2)
USAGE = """\
%prog [OPTIONS] [FILENAME] [JSON_DITDICT]
%prog --csv [OPTIONS] [FILENAME] [JSON_DITDICT] [COLUMNS...]

DESCRIPTION
  Simple JSON analyzer and filter with dotdict notation + wildcard support.

JSON_DOTDICT
  '.name1.name2[999].name3' - full path
  '[0].name1.name2'         - if a top level object is an array.
  'name1.name2[999].name3'  - You can ommit proceeding '.'
  'name1.name2[*].name3'    - Array index wildcard (all items of array)
  'name1.name2.name3'       - Implecit list expansion - assume '[*]' is omitted.
  'name1.name2[1,2,3-9]'    (index range is NOT IMPLEMENTED YET)
  'name1.*.name3'           - Wildcard '*'
  'name1.*2.name3'          (partial match is NOT IMPLEMENTED YET.)
  '{name1a,name1b}.name2'   - Expanded to 'name1a.name2' and 'name1a.name2'"""
#
# TODO
#   * Better error and exception handling / ignore DotDictNoMatch(?)
#   * CSV output
#   * Unit test
#   * Multiple subscript / range support for list (subscript_str)
#
# BUGS & KNOWN ISSUES
#   * Not good for big data; this script loads entire input into memory as
#     objects (using json.load() method), thus input must hit into
#     your machines' RAM.
#   * Nested arrays are not supported
#

##############################################################################
import os
import sys
import re
import optparse
import json

#sys.tracebacklimit = 2

class OutFormat:
    Auto, JSON, CSV = range(3)

##############################################################################

def is_number(obj):
    if isinstance(obj, int) or isinstance(obj, long) or isinstance(obj, float):
        return True
    else:
        return False


def is_rawtype(obj):
    return isinstance(obj, basestring) or is_number(obj)



##############################################################################
# "name" is shorthand for "TOP.name" or "TOP[*].name"
# "[99].name" is shorthand for "TOP[99].name"
# "name1.name2" is shorthand for "name1[*].name2" or even "name1[*].name2"
# when name1 and/or name2 is an array.


def debug(msg):
    #print "DEBUG: ", msg
    pass

def concat(mylist):
    return "".join(mylist)

class DotDictError(Exception):
    def __init__(self, msg=''):
        if isinstance(msg, list):
            self.msg = concat(msg)
        else:
            self.msg = msg
    def __str__(self):
        return self.msg.__str__()

class DotDictMalformed(DotDictError):
    pass

class DotDictNoMatch(DotDictError):
    pass

res = {
        "delim": "[\[\.]",
        "name":  "([A-Za-z]\w*|\*)",
        "index": "(?:\[(?P<index>\d+|\*)\])"
}
names = { "names": "%(name)s(%(delim)s.+)?" % res }
res['multi'] = "%(names)s(?:,%(names)s)*" % names

re_delim = re.compile("^%(delim)s"%res)
re_name  = re.compile("^\.%(name)s(?P<rest>%(delim)s.+)*$" % res)
re_index = re.compile("^%(index)s(?P<rest>%(delim)s.+)*$" % res)
re_multi = re.compile("^\.\{(?P<multi>%(multi)s)\}(?P<rest>%(delim)s.+)*$" % res)


def dotdictget(myjson, dotdict):
    """Wrapper for _dotdictget() to allow omiting topmost object/array index
    """
    if re_delim.match(dotdict):
        normalized_dotdict = dotdict
    else:
        normalized_dotdict = '.' + dotdict

    return _dotdictget(myjson, normalized_dotdict, [])


def _dotdictget_dict(mydict, name, rest, traversed=[]):
    trace = traversed + ["."+name]
    if not isinstance(mydict,dict):
        raise DotDictNoMatch(trace)

    try:
        if name == '*':
            wildcard_expanded = {}
            for n in mydict.keys():
                try:
                    wildcard_expanded[n] = _dotdictget(mydict[n], rest, trace)
                except DotDictNoMatch:
                    pass
            if wildcard_expanded:
                return wildcard_expanded
            else:
                raise DotDictNoMatch(concat(trace) + rest)
        else:
            return {name: _dotdictget(mydict[name], rest, trace)}
    except KeyError:
        raise DotDictNoMatch(trace)


def _dotdictget_list(mylist, index_s, rest, traversed=[]):
    trace = traversed+["[%s]"%index_s]
    if isinstance(mylist,list):
        if index_s == '*':
            list_expanded = []
            for j in mylist:
                try:
                    list_expanded.append( _dotdictget(j, rest, trace) )
                except DotDictNoMatch:
                    pass
            if list_expanded:
                return list_expanded
            else:
                raise DotDictNoMatch(trace)
        else:
            index = int(index_s)
            try:
                subtree = _dotdictget(mylist[index], rest, trace)
                return [subtree]
            except IndexError:
                raise DotDictNoMatch(trace)
    else:
        raise DotDictNoMatch(trace)


def _dotdictget(myjson, dotdict, traversed=[]):
    debug("dotdict: %s/%s"%("".join(traversed), dotdict or "$"))
    if not dotdict or dotdict == '':
        debug("    Leaf: " + ''.join(traversed))
        return myjson
    else:
        m_name  = re_name.match(dotdict)
        m_index = re_index.match(dotdict)
        m_multi = re_multi.match(dotdict)
        if m_name:
            if isinstance(myjson,list):
                return _dotdictget_list(myjson, '*', dotdict, traversed)
            else:
                name = m_name.group(1)
                rest = m_name.group('rest')
                return _dotdictget_dict(myjson, name, rest, traversed)

        elif m_index:
            index_s = m_index.group(1)
            rest  = m_index.group('rest')
            return _dotdictget_list(myjson, index_s, rest, traversed)

        elif m_multi:
            if isinstance(myjson,list):
                return _dotdictget_list(myjson, '*', dotdict, traversed)
            else:
                multi = m_multi.group('multi').split(',')
                rest  = m_multi.group('rest') or ""
                multi_expanded = {}
                for path in multi:
                    newpath = "." + path + rest
                    debug("NEWPATH: " + newpath)
                    ret = _dotdictget(myjson, newpath, traversed)
                    multi_expanded.update( ret )
                return multi_expanded

        else:
            raise DotDictMalformed(dotdict)





##############################################################################

def print_csv(mylist, filter_columns=None, escape=True):
    if isinstance(mylist, list):
        if len(mylist) == 1:
            print_csv(mylist[0], filter_columns, escape)
        else:
            print "Not implemented yet"
            pass
    elif isinstance(mylist,dict) and len(mylist) == 1:
        print_csv(mylist.values()[0], filter_columns, escape)
    else:
        raise DotDictMalformed("Cannot convert non-list data to CSV")



##############################################################################

def print_json_pretty(obj, force=False):
    """If obj is simply an array or raw data type, or a dict with
    only key-value pair in it, print as text.
    Otherwise dump it as JSON.
    """
    if is_rawtype(obj):
        print obj
    elif isinstance(obj, list):
        if all([ is_rawtype(i) for i in obj ]):
            for item in obj:
                print item
        elif all([ isinstance(i, dict) and len(i.keys()) == 1 and is_rawtype(i.values()[0])
                 for i in obj ]):
            for one_item_dict in obj:
                print one_item_dict.values()[0]
        elif not force:
            print json.dumps(obj, indent=4)
        else:
            # failed to pretty-print the object and need to back-track
            return True
    elif isinstance(obj, dict) and len(obj.keys()) == 1:
        # if the obj is dict with one key, try to pretty the inner obj.
        # FIXME for 'single1.single2_3.single3_3'
        if print_json_pretty( obj.values()[0], force=True ):
            if force:
                return True
            else:
                print json.dumps(obj, indent=4)
    elif force:
        return True
    else:
        print json.dumps(obj, indent=4)



##############################################################################

def myoptparse(argv):
    ## Option Parser
    parser = optparse.OptionParser(
        usage=USAGE,
        version=("%%prog %d.%d" % VERSION) )
    parser.add_option("-a", "--auto",
        action="store_const", dest="outformat", const=OutFormat.Auto,
        help="Text output for simple data structure, JSON otherwise")
    parser.add_option("-c", "--csv",
        action="store_const", dest="outformat", const=OutFormat.CSV,
        help="Try to output in CSV format (table like data structure only).")
    parser.add_option("-j", "--json",
        action="store_const", dest="outformat", const=OutFormat.JSON,
        help="Always output in JSON format")

    #parser.add_option("-H", "--no-csv-header",
    #    action="store_true",
    #    help="Print header for Comma Separated Value output.")

    (opt, args) = parser.parse_args(argv)
    return (opt, args)


def json_filter(args):
    infile  = sys.stdin
    dotdict = None
    if len(args) == 0:
        pass
    elif len(args) == 1:
        if os.path.exists(args[0]):
            infile  = open(args[0])
        else:
            dotdict = args[0]
    elif len(args) == 2:
        infile  = open(args[0])
        dotdict = args[1]
    else:
        sys.stderr.write("Too many (%d) arguments\n"%len(args))
        sys.exit(1)

    if dotdict:
        try:
            myjson = dotdictget( json.load(infile), dotdict )
        except DotDictNoMatch as e:
            sys.stderr.write("No matching object found for '%s'\n"%e)
            sys.exit(1)
        except DotDictMalformed as e:
            sys.stderr.write("Malformed DotDict notation: '%s' in '%s'\n" %(e, dotdict))
            sys.exit(1)
    else:
        myjson = json.load( infile )


    if dotdict and len(myjson) == 0:
         raise ValueError("No matching JSON attribute found in the input")

    return (myjson, dotdict)


def main():
    try:
        (opt, args) = myoptparse(sys.argv[1:])
        (myjson, dotdict) = json_filter(args)

        if opt.outformat == OutFormat.CSV:
            print_csv(myjson)
        elif opt.outformat == OutFormat.JSON:
            print json.dumps(myjson, indent=4)
        else:
            print_json_pretty(myjson)

    except KeyboardInterrupt:
        sys.exit(1)


if __name__ == "__main__":
    main()
