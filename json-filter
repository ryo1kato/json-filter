#!/usr/bin/env python
#
# Dumb simple JSON accessor with dotdict notation support.
#
# Dotdict notation of "data.capacityList[0].capacity.hostName"
# is equivalent to "['capacityList'][0]['capacity']['hostName']" of Python
#

VERSION = (0,2)
USAGE = """\
%prog [OPTIONS] [FILENAME] [JSON_DITDICT]
%prog --csv [OPTIONS] [FILENAME] [JSON_DITDICT] [--columns=COLNAME1[,COLNAME2[,...]]]
DESCRIPTION
  Simple JSON analyzer and filter with dotdict notation + wildcard support.
JSON_DOTDICT 
  attr1.attr2[999].attr3
  attr1.attr2[*].attr3
  attr1.*.attr3
\
"""

#
# TODO
#   * CSV output
#   * Better error and exception handling
#   * Unit test
#   * Multiple subscript / range support for list (subscript_str)
#
# BUGS & KNOWN ISSUES
#   * Not for big data; this script loads entire input into memory as
#     objects (using json.load() method), thus input must hit into
#     your machines' RAM.
#

##############################################################################
import os
import sys
import re
import optparse
import json

sys.tracebacklimit = 2

class OutFormat:
    Auto, JSON, CSV = range(3)

##############################################################################

def is_number(obj):
    if isinstance(obj, int) or isinstance(obj, long) or isinstance(obj, float):
        return True
    else:
        return False


def is_rawtype(obj):
    return isinstance(obj, basestring) or is_number(obj)



##############################################################################
re_name      = "([A-Za-z]\w*)"    # group 1
re_subscript = "(\[(\d+|\*)\])?"  # group 2 and 3
re_condition = "(\([=<>]\w+(\|[=<>]\w+)*\))?"
re_node      = {'re_node': re_name + re_subscript + re_condition}

re_dotdict    = re.compile("^%(re_node)s$" % re_node)
re_dotdict_multi = re.compile("^\{(%(re_node)s(,%(re_node)s)*)\}$" % re_node)



def dotdictget(myjson, dotdict):
    node_str, _, rest = dotdict.partition('.')

    single_node = re_dotdict.match(node_str)
    multi_node  = re_dotdict_multi.match(node_str)

    if single_node:
        keys = [ node_str ]
    elif multi_node:
        keys = multi_node.group(1).split(',')
    else:
        raise ValueError("Malformed JSON object path")

    if isinstance(myjson, list):
        return [ dotdictget2(j, keys, rest) for j in myjson ]
    else:
        return dotdictget2(myjson, keys, rest)



# handle (multiple) path name and conditions
def dotdictget2(myjson, keys, rest):

    filtered = dict()

    for key in keys:
        parsed = re_dotdict.match(key)
        name       = parsed.group(1)
        subscript  = parsed.group(3)
        conditions = parsed.group(4) # FIXME: not implemented yet.

        rawobj = myjson[name]

        if not subscript or subscript == '':
            objs = rawobj
        else:
            if not isinstance(rawobj, list):
                raise TypeError("Invalid JSON object path: %s is not an array"%name)

            if subscript == '*':
                objs = rawobj
            else:
                objs = [ rawobj[int(subscript)] ]

        if not rest or rest == '':
            filtered[name] = objs
        else:
            filtered[name] = dotdictget(objs, rest)

    return filtered


##############################################################################

def print_json_pretty(obj):
    """If obj is a simple array or raw data type, print as text
    otherwise dump it as JSON.
    """
    if is_rawtype(obj):
        print obj
    elif isinstance(obj, list) and json == False \
         and len(obj) == len([i for i in obj if is_rawtype(i)]):
        for item in obj:
            print item
    else:
        print json.dumps(obj, indent=4)



def print_csv_dict(myDictList, filter_columns=None, escape=True):
    """print array of dict as csv
    """
    def getcol(row, col):
            if colname in row:
                return str(row[colname])
            else:
                return '__' + colname + '__'

    if filter_columns:
        colnames = filter_columns
    else:
        colnames = myDictList[0].keys()

    for row in myDictList:
        # FIXME: check here data type(?) is dict for all rows
        cols = [ getcol(row, colname) for colname in colnames ]

        # FIXME: should escape the comma
        #for cell in cols:
        #    if ',' in cell:
        #        raise ValueError("',' in the data")

        print ','.join( cols )


def print_csv_list(myListList, filter_columns=None, escape=True):
    nr_cols = len(myListList[0])

    if filter_columns:
        for row in myListList:
            print ','.joins(   [ row[int(col)] for col in filter_columns ]  )
    else:
        for row in myListList:
            print ','.join( row )


def print_csv(mylist, filter_columns=None, escape=True):
    if not isinstance(mylist, list):
        raise TypeError("Non-list data")
    
    if isinstance(mylist[0], dict):
        print_csv_dict(mylist, filter_columns, escape)
    elif isinstance(mylist[0], list):
        print_csv_list(mylist, filter_columns, escape)
    elif is_rawtype(mylist[0]):
        for item in mylist:
            print item
    else:
        raise TypeError("Unrecognizable data")



##############################################################################

def myparser(argv):
    ## Option Parser
    parser = optparse.OptionParser(
        usage=USAGE,
        version=("%%prog %d.%d" % VERSION) )

    parser.add_option("-a", "--auto",
        action="store_const", dest="outformat", const=OutFormat.Auto,
        help="Output in JSON format for complex data structure, " +
             "text output for data only with primitive data type (default)")

    parser.add_option("-c", "--csv",
        action="store_const", dest="outformat", const=OutFormat.CSV,
        help="Output in Comma Separated Value format.")

    parser.add_option("-j", "--json",
        action="store_const", dest="outformat", const=OutFormat.JSON,
        help="Output in JSON format even for simple array only with primitive data type, " +
             "like array of numbers or strings")



    #parser.add_option("-H", "--no-csv-header",
    #    action="store_true",
    #    help="Print header for Comma Separated Value output.")

    (opt, args) = parser.parse_args(argv)
    return (opt, args) 



def json_filter(args):
    if len(args) == 0:
        myjson = json.load(sys.stdin)
    elif len(args) == 1:
        if os.path.exists(args[0]):
            myjson = json.load( open(args[0]) )
        else:
            myjson = dotdictget(  json.load(sys.stdin), args[0]   )
    elif len(args) == 2:
        myjson = dotdictget(  json.load(open(args[0])), args[1]   )
    else:
        sys.stderr.write("Too many (%d) arguments\n"%len(args))
        sys.exit(1)

    if len(myjson) == 0:
         raise ValueError("No matching JSON attribute found in the input")

    return myjson



def main():
    try:
        (opt, args) = myparser(sys.argv[1:])

        myjson = json_filter(args)

        if opt.outformat == OutFormat.CSV:
            firstkey = myjson.keys()[0]
            mylist = myjson[firstkey]
            print_csv( mylist )
        elif opt.outformat == OutFormat.JSON:
            print json.dumps(json, indent=4)
        else:
            print_json_pretty(myjson)

    except KeyboardInterrupt:
        sys.exit(1)


if __name__ == "__main__":
    main()
