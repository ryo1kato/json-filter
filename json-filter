#!/usr/bin/env python
#
# Dumb simple JSON accessor with dotdict notation support.
#
# Dotdict notation of "data.capacityList[0].capacity.hostName"
# is equivalent to "['capacityList'][0]['capacity']['hostName']" of Python
#

VERSION = (0,2)
USAGE = """\
%prog [OPTIONS] [FILENAME] [JSON_DITDICT]
%prog --csv [OPTIONS] [FILENAME] [JSON_DITDICT] [--columns=COLNAME1[,COLNAME2[,...]]]
DESCRIPTION
  Simple JSON analyzer and filter with dotdict notation + wildcard support.
JSON_DOTDICT 
  attr1.attr2[999].attr3
  attr1.attr2[*].attr3
  attr1.attr2.attr3(attr4=val4)
  attr1.attr2.attr3.attr4(=val4)
\
"""

#
# TODO
#   * CSV output
#   * Better error and exception handling
#   * Unit test
#   * Multiple subscript / range support for list (subscript_str)
#
# BUGS & KNOWN ISSUES
#   * Not for big data; this script loads entire input into memory as
#     objects (using json.load() method), thus input must hit into
#     your machines' RAM.
#

##############################################################################
import os
import sys
import re
import optparse
import json

sys.tracebacklimit = 2

class OutFormat:
    Auto, JSON, CSV = range(3)

##############################################################################

def is_number(obj):
    if isinstance(obj, int) or isinstance(obj, long) or isinstance(obj, float):
        return True
    else:
        return False


def is_rawtype(obj):
    return isinstance(obj, basestring) or is_number(obj)



##############################################################################

re_name      = "([A-Za-z]\w*)"    # group 1
re_subscript = "(\[(\d+|\*)\])?"  # group 2 and 3
re_condition = "(\([=<>]\w+(\|[=<>]\w+)*\))?"
re_node      = {'re_node': re_name + re_subscript + re_condition}

re_dotdict    = re.compile("^%(re_node)s$" % re_node)
re_dotdict_multi = re.compile("^\{(%(re_node)s(,%(re_node)s)*)\}$" % re_node)


def dotdictget(myjson, dotdict):
    node_str, _, rest = dotdict.partition('.')

    single_node = re_dotdict.match(node_str)
    multi_node  = re_dotdict_multi.match(node_str)

    if single_node:
        keys = [ node_str ]
    elif multi_node:
        keys = multi_node.group(1).split(',')
    else:
        raise ValueError("Malformed JSON object path")

    parsed_keys = []
    for k in keys:
        parsed = re_dotdict.match(k)
        parsed_keys.append(( parsed.group(1), parsed.group(3), parsed.group(4) ))

    if isinstance(myjson, list):
        return [ _dotdictget(j, parsed_keys, rest) for j in myjson ]
    else:
        return _dotdictget(myjson, parsed_keys, rest)


# handle (multiple) path name and conditions
def _dotdictget(myjson, parsed_keys, rest):
    filtered = dict()
    for pk in parsed_keys:
        name       = pk[0]
        subscript  = pk[1]
        conditions = pk[2] # FIXME: not implemented yet.

        rawobj = myjson[name]

        if not subscript or subscript == '':
            objs = rawobj
        else:
            if not isinstance(rawobj, list):
                raise TypeError("Invalid JSON object path: %s is not an array"%name)

            if subscript == '*':
                objs = rawobj
            else:
                objs = [ rawobj[int(subscript)] ]

        if not rest or rest == '':
            filtered[name] = objs
        else:
            filtered[name] = dotdictget(objs, rest)

    return filtered


##############################################################################

def print_json_pretty(obj, force=False):
    """If obj is simply an array or raw data type, or a dict with
    only key-value pair in it, print as text.
    Otherwise dump it as JSON.
    """
    if is_rawtype(obj):
        print obj
    elif isinstance(obj, list):
        if all([ is_rawtype(i) for i in obj ]):
            for item in obj:
                print item
        elif all([ isinstance(i, dict) and len(i.keys()) == 1 and is_rawtype(i.values()[0])
                 for i in obj ]):
            for one_item_dict in obj:
                print one_item_dict.values()[0]
        elif not force:
            print json.dumps(obj, indent=4)
        else:
            # failed to pretty-print the object and need to back-track
            return True
    elif isinstance(obj, dict) and len(obj.keys()) == 1:
        # if the obj is dict with one key, try to pretty the inner obj.
        if print_json_pretty( obj.values()[0], force=True ):
            print json.dumps(obj, indent=4)
    else:
        print json.dumps(obj, indent=4)


def print_csv_dict(myDictList, filter_columns=None, escape=True):
    """print array of dict as csv
    """
    def getcol(row, col):
            if colname in row:
                return str(row[colname])
            else:
                return '__' + colname + '__'

    if filter_columns:
        colnames = filter_columns
    else:
        colnames = myDictList[0].keys()

    for row in myDictList:
        # FIXME: check here data type(?) is dict for all rows
        cols = [ getcol(row, colname) for colname in colnames ]

        # FIXME: should escape the comma
        #for cell in cols:
        #    if ',' in cell:
        #        raise ValueError("',' in the data")

        print ','.join( cols )


def print_csv_list(myListList, filter_columns=None, escape=True):
    nr_cols = len(myListList[0])

    if filter_columns:
        for row in myListList:
            print ','.joins(   [ row[int(col)] for col in filter_columns ]  )
    else:
        for row in myListList:
            print ','.join( row )


def print_csv(mylist, filter_columns=None, escape=True):
    if not isinstance(mylist, list):
        raise TypeError("Non-list data")
    
    if isinstance(mylist[0], dict):
        print_csv_dict(mylist, filter_columns, escape)
    elif isinstance(mylist[0], list):
        print_csv_list(mylist, filter_columns, escape)
    elif is_rawtype(mylist[0]):
        for item in mylist:
            print item
    else:
        raise TypeError("Unrecognizable data")



##############################################################################

def myoptparse(argv):
    ## Option Parser
    parser = optparse.OptionParser(
        usage=USAGE,
        version=("%%prog %d.%d" % VERSION) )

    parser.add_option("-a", "--auto",
        action="store_const", dest="outformat", const=OutFormat.Auto,
        help="Output in JSON format for complex data structure, " +
             "text output for data only with primitive data type (default)")

    parser.add_option("-c", "--csv",
        action="store_const", dest="outformat", const=OutFormat.CSV,
        help="Output in Comma Separated Value format.")

    parser.add_option("-j", "--json",
        action="store_const", dest="outformat", const=OutFormat.JSON,
        help="Output in JSON format even for simple array only with primitive data type, " +
             "like array of numbers or strings")



    #parser.add_option("-H", "--no-csv-header",
    #    action="store_true",
    #    help="Print header for Comma Separated Value output.")

    (opt, args) = parser.parse_args(argv)
    return (opt, args) 


def json_filter(args):
    infile  = sys.stdin
    dotdict = None
    if len(args) == 0:
        pass
    elif len(args) == 1:
        if os.path.exists(args[0]):
            infile  = open(args[0]) 
        else:
            dotdict = args[0]
    elif len(args) == 2:
        infile  = open(args[0]) 
        dotdict = args[1]
    else:
        sys.stderr.write("Too many (%d) arguments\n"%len(args))
        sys.exit(1)

    if dotdict:
        myjson = dotdictget( json.load(infile), dotdict )
    else:
        myjson = json.load( infile )


    if dotdict and len(myjson) == 0:
         raise ValueError("No matching JSON attribute found in the input")

    return (myjson, dotdict)


def main():
    try:
        (opt, args) = myoptparse(sys.argv[1:])
        (myjson, dotdict) = json_filter(args)

        if opt.outformat == OutFormat.CSV:
            #print json.dumps(myjson, indent=4)
            #for row in json2table( myjson, dotdict ):
            #    print ",".join(row)
            pass
        elif opt.outformat == OutFormat.JSON:
            print json.dumps(myjson, indent=4)
        else:
            print_json_pretty(myjson)

    except KeyboardInterrupt:
        sys.exit(1)


if __name__ == "__main__":
    main()
